<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Gatsby Starter Blog RSS Feed]]></title><description><![CDATA[주로 제가 개발하면서 느낀 경험, 이슈들을 주되게 작성합니다. 이슈 해결방법보다는 이슈가 생겼던 이유, 개념에 대한 설명을 작성합니다.]]></description><link>https://jsh0128.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Wed, 22 Nov 2023 13:13:43 GMT</lastBuildDate><item><title><![CDATA[react-hook-form]]></title><description><![CDATA[react-hook-form 동작 방식 등 기본적인 것들에 대해서 하는 글입니다 👏 react-hook-form은 렌더링 개선을 위해 만들어진 라이브러리입니다.
useState를 이용하여 Input의 value를 관리하면, input…]]></description><link>https://jsh0128.github.io/develop/react-hook-form/</link><guid isPermaLink="false">https://jsh0128.github.io/develop/react-hook-form/</guid><pubDate>Fri, 04 Aug 2023 00:00:02 GMT</pubDate><content:encoded>&lt;p&gt;react-hook-form 동작 방식 등 기본적인 것들에 대해서 하는 글입니다 👏&lt;/p&gt;
&lt;p&gt;react-hook-form은 렌더링 개선을 위해 만들어진 라이브러리입니다.
useState를 이용하여 Input의 value를 관리하면, input에 onChange를 걸게되며 onChange 실행 시 useState관리하는 컴포넌트가 &lt;strong&gt;re-render&lt;/strong&gt; 됩니다. 이런 점을 해결하기 위해 나온 lib가 &lt;strong&gt;react-hook-form&lt;/strong&gt;입니다 👍&lt;/p&gt;
&lt;p&gt;react-hook-form 사용시 기본 모드로 사용하게 되면 register로 관리하게 되는데 register를 log 찍게 되면 name, ref, onChange, onBlur이 나오게 됩니다.
&lt;img width=&quot;375&quot; alt=&quot;image&quot; src=&quot;https://github.com/jsh0128/Blog/assets/52942411/2c9c8ba3-2908-4a27-8dc9-2ef7f5ed2c48&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;위의 사진을 참고하면 onBlur, onChange는 비동기입니다.
TypeScript 사용시 Promise로 타입을 반환하여 async await을 사용하게 되면 비동기로 동작하게 됩니다 !&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;register를 받아서 input에 전달하게 되면 onChange시에 렌더를 하지 않습니다.&lt;/strong&gt;
onChange시에 ref에 값을 전달 -&gt; onSubmit 을 하게되면 ref에 있는 값을 들고옴.&lt;/p&gt;
&lt;p&gt;input에 &lt;strong&gt;useState&lt;/strong&gt;로 관리하면 onChange시 값을 변경하게 되면 &lt;strong&gt;re-render&lt;/strong&gt;하는 반면 register로 관리하게 되면 상단에서 state를 관리해도 &lt;strong&gt;re-render&lt;/strong&gt;가 일어나지 않기 때문에 성능면에서 더 좋은 이점을 챙길 수 있습니다.&lt;/p&gt;
&lt;p&gt;극명하게 차이나는 시점은 아마 모달에서 input을 몇십개 이상 관리하는 컴포넌트에서 성능이 극명하게 차이가 난다고 생각합니다.&lt;/p&gt;
&lt;p&gt;예를 들어 onClick을 할때 서버에 값을 보내야 되는 상황에 모달에 input이 몇십개가 넘는 상황이면 모달에서 useState 전체를 관리하게 될것입니다.
그럼 input 하나의 값을 변경할 때 마다 모달 전체가 rerender가 일어나게 되며 성능에 큰 이슈를 줄 수 있으며 웹 사이트 자체가 버벅거림을 느낄 수도 있습니다. 하지만 react-hook-form으로 관리하게 되면 이런 일을 미연에 방지할 수 있습니다.&lt;/p&gt;
&lt;p&gt;하지만 react-hook-form도 단점이 없을 수 있다고 할 수는 없습니다. 만약 UI 라이브러리를 사용하게 되면, 당연히 호환성이 안맞을 수 있으며 사용에 있어 어려움을 겪을 수 있습니다. 더 극명한 예를 들게 된다면 MUI와 react-hook-form을 같이 쓰게 된다면 더 어려움을 느낄 수 있을 것 입니다.&lt;/p&gt;
&lt;p&gt;왜냐하면 MUI 자체의 form을 지원하기 때문에(어떤식으로 동작하는지에 대한 이해는 없습니다.) React-hook-form과 사용함에 어려움이 있을 수 있습니다. 이부분에 유의하며 리렌더링 등 성능문제에 신경쓰며 개발해야 됩니다. 내가 현재 어떤 기술스택을 사용중인지 고려해보고 잘 도입해보시면 좋을 것 같습니다.&lt;/p&gt;
&lt;p&gt;오늘 포스팅은 여기서 마치도록 하겠습니다. 감사합니다 :)&lt;/p&gt;</content:encoded></item><item><title><![CDATA[CSR, SSR, SSG]]></title><description><![CDATA[회사에서 처음으로 SSG 렌더링 방식을 접하고 좀 얕게 지식을 가지고 있다가, 이번에 블로그 만들겸 해서 공부하게 되었습니다. SSG의 렌더링 방식 하나를 설명하기 보다는 CSR, SSR…]]></description><link>https://jsh0128.github.io/develop/csr,ssr,-ssg/</link><guid isPermaLink="false">https://jsh0128.github.io/develop/csr,ssr,-ssg/</guid><pubDate>Sat, 06 May 2023 22:06:32 GMT</pubDate><content:encoded>&lt;p&gt;회사에서 처음으로 &lt;strong&gt;SSG&lt;/strong&gt; 렌더링 방식을 접하고 좀 얕게 지식을 가지고 있다가, 이번에 블로그 만들겸 해서 공부하게 되었습니다.&lt;/p&gt;
&lt;p&gt;SSG의 렌더링 방식 하나를 설명하기 보다는 &lt;strong&gt;CSR, SSR&lt;/strong&gt;도 같이 설명해보면 좋겠다고 생각되어 이와 같이 글을 쓰게 되었습니다 😀&lt;/p&gt;
&lt;h2&gt;CSR은 무엇인가&lt;/h2&gt;
&lt;p&gt;CSR는 약자이며 명칭은 Client Side Rendering입니다. 현재 React, Vue, Angular에서 채택된 렌더링 방식입니다.&lt;/p&gt;
&lt;p&gt;클라이언트에서 HTML을 그리며, JS가 동작하면서 필요한 데이터들을 주고 받아서 &lt;strong&gt;클라이언트에서만 렌더링&lt;/strong&gt;을 하게 되는 방식을 뜻합니다.&lt;/p&gt;
&lt;p&gt;CSR의 장점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;초기 로딩 이후 페이지 전환이 빠르다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서버의 부담을 줄일 수 있다 혹은 웹 서버를 띄울 필요가 없다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CSR의 단점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SEO에 좋지않다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서버에서 html을 내려주는 것이 아니라 페이지 접속 시에 html을 그리는 것이기 때문에 검색 엔진 봇이 빈 html로 인식할 수 있기 때문&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;초기 로딩이 많이 걸린다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;첫 로딩시 html을 그리고, js를 불러와야 되기 때문&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;SSR은 무엇인가&lt;/h2&gt;
&lt;p&gt;SSR은 약자이며 명칭은 Server Side Rendering입니다. 서버에서 먼저 사용자에게 보여줄 페이지를 그리고 내려주는 방식입니다.&lt;/p&gt;
&lt;p&gt;첫 페이지에 도착하는 속도는 CSR보다 느릴 수 있지만, 화면이 구성되어 보여지는 시점은 더 빠릅니다.&lt;/p&gt;
&lt;p&gt;왜냐하면 CSR은 페이지 접속 시 빈 HTML을 보여주고 그 후에 HTML을 다시 재구성하기 때문에, 보여지는 시점은 SSR이 더 빠르다고 할 수 있습니다.&lt;/p&gt;
&lt;p&gt;SSR의 장점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;첫 페이지 렌더링 속도가 빠르다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SEO에 좋다. - 이미 만들어진 html을 들고 있기 때문에 검색 엔진 봇이 크롤링이 가능하기 때문&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SSR의 단점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;페이지 이동시 지속적으로 서버에 요청하여 페이지 이동이 느리다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;추가적인 웹 서버를 띄어야 함.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;SSG는 무엇인가&lt;/h2&gt;
&lt;p&gt;SSG는 약자이며 명칭은 Static Site Generation입니다. build 시점에 미리 html과 css를 만드는 방식입니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ISR&lt;/strong&gt;(Incremental Static Regeneration)이라는 개념도 있는데 이 개념도 SSG에 포함된다고 생각하시면 되겠습니다.&lt;/p&gt;
&lt;p&gt;ISR은 build 시점에 페이지를 렌더링 한 후 설정한 시간마다 페이지를 새로 렌더링합니다. 그럼 어느정도의 동적으로도 사용가능해집니다.&lt;/p&gt;
&lt;p&gt;백오피스를 만드는데 SSG의 렌더링 방식을 사용하여서 개발중입니다. 확실히 느낀점은 초기 렌더링은 CSR보다 빨라서 좋더라구요. 그리고 페이지 이동을 하여도 이미 만들어진 html과 css가 있기 때문에 느리지 않다고 좋다는 느낌을 많이 받았습니다.&lt;/p&gt;
&lt;p&gt;현재 S3, Cloudfront, Route53을 통하여 배포하고, dynamic routing은 lambda@Edge를 사용하여 해결하고 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jsh0128/jsh0128.github.io/assets/52942411/735e5b34-d2fd-4099-b8cb-8c995ea445ea&quot; alt=&quot;Group 15 (1)&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ISR을 도입 안한 이유는&lt;/strong&gt; 새로 만든 페이지를 프론트에서 지속적으로 들고있어야 하는데 이 페이지수가 적은 양도 아니였고, 이미 html과 css는 build시점에 만들었기 때문에 페이지 이동 속도 측면에서 느리지 않다고 판단했기 때문입니다.&lt;/p&gt;</content:encoded></item></channel></rss>